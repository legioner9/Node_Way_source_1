# [[в закладки] Bash для начинающих: 21 полезная команда](https://habr.com/ru/company/ruvds/blog/445270/)

## 21 Bash-команда

### ▍Получение информации

* man: выводит руководство пользователя (справку) по команде.
* pwd: выводит сведения о рабочей директории.
* ls: выводит содержимое директории.
* ps: позволяет пр
осматривать сведения о работающих процессах.

### ▍Манипуляции с файловой системой

* cd: изменение рабочей директории.
* touch: создание файла.
* mkdir: создание директории.
* cp: копирование файла.
* mv: перемещение или удаление файла.
* ln: создание ссылки.


### ▍Перенаправление ввода-вывода и конвейеры

* <: перенаправление stdin.
* \>: перенаправление stdout.
* |: перенаправление с помощью конвейера вывода одной команды на вход другой команды.


### ▍Чтение файлов

* head: чтение начала файла.
* tail: чтение конца файла.
* cat: чтение файла и вывод его содержимого на экран или конкатенация файлов.


### ▍Удаление файлов, остановка процессов

* rm: удаление файла.
* kill: остановка процесса.


### ▍Поиск

* grep: поиск информации.
* ag: прод
винутая команда для поиска.

### ▍Архивация

* tar: создание архивов и работа с ними.

Поговорим об этих командах подробнее.

Подробности о командах

Для начала давайте разберёмся с командами, результаты работы которых выдаются в форме stdout. Обычно эти результаты появляются в окне терминала.

### ▍Получение информации

    man command_name
##### : вывод руководства по команде,
то есть — справочной информации.

    pwd
##### : вывод на экран пути к текущей рабочей директории. 
В ходе работы с командной строкой пользователю часто нужно узнавать то, где именно в системе он находится.

    ls
##### : вывод содержимого директории. 
Эта команда тоже используется весьма часто.

    ls -a
##### : вывод скрытых файлов.
Здесь применён флаг -a команды ls. Использование флагов помогает настраивать поведение команд.

    ls -l
##### : вывод подробной информации о файлах.

Обратите внимание на то, что флаги можно комбинировать. Например — так##### : ls -al.

    ps
##### : просмотр выполняющихся процессов.

    ps -e
##### : вывод сведений обо всех выполняющихся процессах, 
а не только о тех, которые связаны с текущей оболочкой пользователя. Данную команду часто используют именно в таком виде.

### ▍Манипуляции с файловой системой

    cd my_directory
##### : изменение рабочей директории на my_directory. 
Для того чтобы перейти на один уровень выше в дереве каталогов используйте в качестве my_directory относительный путь ../.



#### Команда cd

    touch my_file
##### : создание файла my_file по заданному пути.

    mkdir my_directory
##### : создание папки my_directory по заданному пути.

    mv my_file target_directory
##### : перемещение файла my_file в папку target_directory.
При указании целевой директории нужно использовать абсолютный путь к ней (а не конструкцию вроде ../).

Команду mv, кроме того, можно использовать для переименования файлов или папок. Например, выглядеть это может так:

    mv my_old_file_name.jpg my_new_file_name.jpg
    cp my_source_file target_directory
##### : создание копии файла my_source_file и помещение её в папку target_directory.

    ln -s my_source_file my_target_file
##### : создание символической ссылки my_target_file на файл
my_source_file. Если изменить ссылку, то изменится и исходный файл.

Если файл my_source_file будет удалён, то my_target_file останется. Флаг -s команды ln позволяет создавать ссылки и для директорий.

Теперь поговорим о перенаправлении ввода-вывода и конвейерах.

### ▍Перенаправление ввода-вывода и конвейеры

    my_command < my_file
##### : заменяет дескриптор файла стандартного ввода (stdin) на файл my_file
. Это может оказаться полезным в том случае, если команда ожидает ввода неких данных с клавиатуры, а эти данные заранее сохранены в файле.

    my_command > my_file
##### : перенаправляет результаты работы команды, то есть то, что обычно попадает в stdout и выводится на экран, 
в файл my_file. Если файл my_file не существует — он создаётся. Если файл существует — он перезаписывается.

Например, после выполнения команды ls > my_folder_contents.txt будет создан текстовый файл, содержащий список того, что находится в текущей рабочей директории.

Если вместо символа > воспользоваться конструкцией >>, то, при условии существования файла, в который перенаправляется вывод команды, этот файл перезаписан не будет. Данные будут добавлены в конец этого файла.

Теперь взглянем на конвейерную обработку данных.



То, что выводит одна команда, подаётся на вход другой команды. Это похоже на подключение одной трубы к другой

    first_command | second_command
##### : символ конвейера, |, используется для того чтобы отправить результаты работы одной команды другой команде.
То, что команда, находящаяся в левой части описываемой конструкции, отправляет в stdout, попадает в stdin команды, которая находится справа от символа конвейера.

В Linux конвейерную обработку данных можно организовать с использованием практически любой правильно составленной команды. Часто говорят, что всё в Linux — это конвейер.

С помощью символа конвейера можно объединять в цепочку несколько команд. Выглядит это так:

    first_command | second_command | third_command



Конвейер из нескольких команд можно сравнить с трубопроводом

Обратите внимание на то, что когда команда, находящаяся слева от символа |, выводит что-то в stdout, то, что она вывела, немедленно становится доступным в виде stdin второй команде. То есть оказывается, что, используя конвейер, мы имеем дело с параллельным выполнением команд. Иногда это может привести к неожиданным результатам. Подробности об этом можно почитать здесь.

Теперь поговорим о чтении данных из файлов и о выводе их на экран.

### ▍Чтение файлов

    head my_file
##### : считывает строки из начала файла и выводит их на экран.
Читать можно не только содержимое файлов, но и то, что команды выводят в stdin, используя эту команду в качестве элемента конвейера.

    tail my_file
##### : считывает строки из конца файла.
Эту команду тоже можно использовать в конвейере.



Head (голова) находится спереди, а tail (хвост) — сзади

Если вы работаете с данными, используя библиотеку pandas, тогда команды head и tail должны быть вам знакомы. Если это не так — взгляните на вышеприведённый рисунок, и вы без труда их запомните.

Рассмотрим другие способы чтения файлов, поговорим о команде cat.

Команда cat либо выводит содержимое файла на экран, либо конкатенирует несколько файлов. Это зависит от того, сколько файлов передано этой команде при вызове.



#### Команда cat

    cat my_one_file.txt
##### : когда этой команде передают один файл — она выводит его в stdout.

Если же передать ей два файла или большее количество файлов, то она ведёт себя по-другому.

    cat my_file1.txt my_file2.txt
##### : получив на вход несколько файлов эта команда конкатенирует их содержимое
и выведет то, что получилось в stdout.

Если результат конкатенации файлов нужно сохранить в виде нового файла, можно воспользоваться оператором >:

    cat my_file1.txt my_file2.txt > my_new_file.txt

Теперь поговорим о том, как удалять файлы и останавливать процессы.

### ▍Удаление файлов, остановка процессов

    rm my_file
##### : удаляет файл my_file.

    rm -r my_folder
##### : удаляет папку my_folder и все содержащиеся в ней файлы и папки
. Флаг -r указывает на то, что команда будет работать в рекурсивном режиме.

Для того чтобы система не запрашивала подтверждение при выполнении каждой операции удаления файла или папки, воспользуйтесь флагом -f.

    kill 012345
##### : останавливает указанный выполняющийся процесс,
давая ему время на корректное завершение работы.

    kill -9 012345
##### : принудительно завершает указанный запущенный процесс. 
Флаг вида -s SIGKILL означает то же самое, что и флаг -9.

### ▍Поиск

Для поиска данных можно использовать разные команды. В частности — grep, ag и ack. Начнём наше знакомство с этими командами с grep. Это — проверенная временем, надёжная команда, которая, правда, медленнее других и не так, как они, удобна в использовании.



#### Команда grep

    grep my_regex my_file
##### : выполняет поиск my_regex в my_file.
При обнаружении совпадений возвращается, для каждого из них, вся строка. По умолчанию my_regex воспринимается как регулярное выражение.

    grep -i my_regex my_file
##### : поиск выполняется без учёта регистра символов.

    grep -v my_regex my_file
##### : возвращает все строки, в которых не содержится my_regex.
Флаг -v означает инверсию, он напоминает оператор NOT, имеющийся во многих языках программирования.

    grep -c my_regex my_file
##### : возвращает сведения о количестве совпадений с искомым шаблоном, найденных в файле.

    grep -R my_regex my_folder
##### : выполняет рекурсивный поиск во всех файлах, находящихся в заданной папке и в папках, вложенных в неё.

Теперь поговорим о команде ag. Она появилась позже grep, она быстрее, работать с ней удобнее.



#### Команда ag

    ag my_regex my_file
##### : возвращает сведения о номерах строк, и сами строки, в которых найдены совпадения с my_regex.

    ag -i my_regex my_file
##### : поиск выполняется без учёта регистра символов.

Команда ag автоматически обрабатывает файл .gitignore и исключает из вывода то, что найдено в папках или файлах, перечисленных в этом файле. Это очень удобно.

    ag my_regex my_file -- skip-vcs-ignores
##### : содержимое файлов систем автоматического контроля версий (наподобие .gitignore) при поиске не учитывается.

Кроме того, для того чтобы указать команде ag на то, какие пути к файлам нужно исключить из поиска, можно создать файл .agignore.

В начале этого раздела мы упомянули о команде ack. Команды ack и ag очень похожи, можно сказать, что они взаимозаменяемы на 99%. Однако команда ag работает быстрее, поэтому я описал именно её.

Теперь поговорим о работе с архивами.

### ▍Архивация

    tar my_source_directory
##### : объединяет файлы из папки my_source_directory в один файл tarball.
Такие файлы удобно использовать для того, чтобы передавать кому-нибудь большие наборы файлов.



#### Команда tar

Tarball-файлы, создаваемые этой командой, представляют собой файлы с расширением .tar (Tape ARchive). То, что в названии команды и в расширении имён файлов, создаваемых ей, скрыто слово «tape» (лента), говорит о том, как давно существует эта команда.

    tar -cf my_file.tar my_source_directory
##### : создаёт tarball-файл с именем my_file.tar с содержимым папки my_source_directory.
Флаг -c расшифровывается как «create» (создание), а флаг -f как «file» (файл).

Для извлечения файлов, находящихся в .tar-файле, используется команда tar c флагами -x («extract», извлечение) и -f («file», файл).

    tar -xf my_file.tar
##### : извлекает файлы из my_file.tar в текущую рабочую директорию.

Теперь поговорим о том, как сжимать и распаковывать .tar-файлы.

    tar -cfz my_file.tar.gz my_source_directory
##### : здесь, с использованием флага -z («zip», алгоритм сжатия) указано, что для сжатия файлов должен использоваться алгоритм gzip (GNU zip)
. Сжатие файлов позволяет экономить дисковое пространство при хранении таких файлов. Если же файлы планируется, например, передавать другим пользователям, это способствует более быстрой загрузке таких файлов.

Распаковать файл .tar.gz можно, добавив флаг -z к команде извлечения содержимого .tar-файлов, которую мы рассматривали выше. Выглядит это так:

    tar -xfz my_file.tar.gz
Надо отметить, что у команды tar есть ещё множество полезных флагов.

## Bash-псевдонимы

Bash-псевдонимы (их ещё называют алиасами или сокращениями) предназначены для создания сокращённых наименований команд или их последовательностей, использование которых вместо обычных команд ускоряет работу. Если у вас, предположим, имеется псевдоним bu, за которым скрывается команда python setup.py sdist bdist_wheel, то для вызова данной команды достаточно воспользоваться этим псевдонимом.

Для создания подобного псевдонима достаточно добавить следующую команду в файл ~/.bash_profile:

alias bu="python setup.py sdist bdist_wheel"

Если в вашей системе нет файла ~/.bash_profile, то вы можете создать его самостоятельно, воспользовавшись командой touch. После создания псевдонима перезапустите терминал, после чего вы сможете этим псевдонимом пользоваться. В данном случае ввод двух символов заменяет ввод более чем трёх десятков символов команды, которая предназначена для сборки Python-пакетов.

В ~/.bash_profile можно добавлять псевдонимы для любых часто используемых команд.
