<div class="glossary_view cc_cursor" style="top: 39px; width: 718px; height: 499px;"><div class="items_list_bg cc_cursor" style="width: 140px; height: 481px;"><div class="component_container items_list_view" style="left: 7px; top: 12px; width: 123.5px; height: 454.5px;"><div class="component_base items_list_view cc_cursor" style="overflow: hidden; width: 100%; height: 100%;"><div class="component_base items_list_view"><div class="item selected" style="font-weight: bold;">Тема 1.</div></div></div><div class="vscrollbar" style="opacity: 0; display: none;"><div class="up"></div><div class="thumb" style="height: 0px; top: 0px;"></div><div class="down"></div></div></div></div><div class="content_item_view cc_cursor" style="width: 549px; height: 479px;"><div class="component_container content" style="width: 548.5px; height: 478.5px;"><div class="component_base content" style="overflow: hidden; width: 100%; height: 100%;"><div class="component_base content cc_cursor"><div class="sections_view cc_cursor" style="width: 526px;"><div class="content"><div class="text section title">Тема 1.</div><div class="text section"><p style="text-align:left;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:26px;">Введение. Ключевые понятия объектно-ориентированного программирования</span></p></div><div class="text section"><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Объектно-ориентированное программирование (ООП) – особый, специфический способ организации программного кода, появившийся в результате длительной эволюции технологии разработки программных продуктов, и сейчас является доминирующим стилем при создании больших программ. Принципы ООП универсальны и не имеют отношения к какому-то определенному языку программирования. «Существующие в настоящее время объектные модели различных версий универсальных языков программирования имеют свои особенности, но в их основе лежат единые концепции, что позволяет говорить о теоретических основах ООП» [11].</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Изучение программирования начинают с процедурного программирования, суть которого заключается в разбиении задачи на последовательность шагов и выполнении их друг за другом.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Первоначально программы писались на машинном языке и представляли собой так называемый опкод – инструкцию машине, что следует делать. Эти программы были довольно просты. Их сложность ограничивалась возможностью программиста мысленно отслеживать последовательность выполняемых операций и местонахождение большого количества данных.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Следующая ступень эволюции программирования – языки ассемблера. Ассемблер – это машинный язык, дополненный конструкциями из языков высокого уровня. Он дает программисту гораздо больше возможностей, но предъявляет определенные требования к его квалификации. Написанный на ассемблере код сложно читать и понимать, в нем затруднено тестирование и отладка.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Эти недостатки способствовали появлению языков высокого уровня. Основная черта таких языков – это абстракция, то есть введение смысловых конструкций, кратко описывающих длинные и сложные для понимания структуры данных и операции над ними. Они позволили писать программы на языке, приближенном к естественному. Создание ассемблеров и языков высокого уровня позволило снизить уровень детализации, что сделало программу более обозримой и, естественно, позволило увеличить ее сложность.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Развитие языков способствовало возрастанию сложности программ. «Появление средств, позволяющих оперировать подпрограммами, существенно снизило трудоемкость разработки программ. Подпрограммы можно было сохранять и использовать в других программах. В результате были накоплены огромные библиотеки расчетных и служебных подпрограмм, которые по мере надобности вызывались из разрабатываемой программы» [10].</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">«На рис. 1.1 представлена архитектура типичной программы прошлых лет, состоящая из основной программы, глобальной области данных и набора подпрограмм, выполняющих обработку всех данных или их части» [11]. </span></p></div><div class="image section center zoomable" style="background: url(&quot;data/intr1/picture1.jpg?t=1614346141103&quot;) center center / 100% 100% no-repeat rgb(255, 255, 255); width: 400px; height: 182px;"><div class="zoom_icon"></div></div><div class="text section cc_cursor"><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">«Слабым местом такой архитектуры было то, что с увеличением количества подпрограмм возрастает вероятность искажения части глобальных данных какой-либо подпрограммой. Например, подпрограмма поиска корней уравнения на заданном интервале по методу деления отрезка пополам меняет величину интервала. Если при выходе из подпрограммы не предусмотреть восстановления первоначального интервала, тогда в глобальной области окажется неверное значение интервала, полученное при последнем делении отрезка в ходе работы программы» [11].</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Для уменьшения вероятности появления ошибки на смену программам с глобальной областью данных пришли программы с локальными данными (рис. 1.2) [11].</span></p></div><div class="image section center zoomable cc_pointer" style="background: url(&quot;data/intr1/picture2.jpg?t=1614346141104&quot;) center center / 100% 100% no-repeat rgb(255, 255, 255); width: 389px; height: 200px;"><div class="zoom_icon"></div></div><div class="text section"><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Такая архитектура позволила размещать локальные данные в подпрограммах. Появление средств поддержки подпрограмм позволило осуществлять разработку программного обеспечения (ПО) нескольким программистам параллельно. Использование локальных данных помогло снизить количество ошибок в подпрограммах, но сложность разрабатываемого ПО все еще ограничивалась возможностью программиста отслеживать процессы обработки данных.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Все эти архитектуры были далеко не совершенны. Существовавшие технологии не справлялись со все возрастающей сложностью программного обеспечения. В результате создание каждой подпрограммы превращалось в непростую задачу. Интерфейсы подпрограмм получались сложными, при сборке программного продукта выявлялось большое количество ошибок согласования. Исправление таких ошибок требовало серьезного изменения разработанных подпрограмм, что еще более осложняло ситуацию. В конце концов процесс тестирования и отладки программ занимал более 80 % времени разработки. В результате встал вопрос создания новой технологии разработки сложных программных продуктов, снижающей вероятность ошибок проектирования.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Были проанализированы проблемы и ошибки, с которыми сталкивались программисты при разработке. В результате в 60–70-е годы прошлого века был сформулирован новый подход к написанию программ, названный структурным.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Структурное программирование – это метод, разработанный для повышения надежности и ясности программ. В структурном программировании управление потоком программы ограничено тремя основными структурами (последовательность, ветвление, цикл) или структурой, производной от комбинации трех основных. В результате получается программа, состоящая из блоков, которые в значительной степени независимы друг от друга. В свою очередь, это позволяет программисту быть более уверенным в том, что код содержит меньше логических ошибок и его будет легче отлаживать и изменять в будущем. Однако структурный подход к программированию может быть менее эффективным, чем неструктурированный аналог.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Также были сформулированы основные принципы проектирования и реализации ПО.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Первое – принцип нисходящей разработки. Это организационный процесс, при котором шаги предпринимаются в следующем порядке: 1) формулируется общая концепция, 2) разрабатывается функциональная спецификация, 3) функциональная спецификация уточняется на каждом промежуточном этапе, где промежуточные шаги включают код или процессы, необходимые для предыдущего шага, и 4) внесены окончательные уточнения, чтобы полностью определить проблему.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Каждая итерация в дизайне программной системы приближает определение каждого уровня к лучшей модульной, сквозной концепции для конкретной рассматриваемой системы. В процессе проектирования станет очевидно, что некоторые модули одного уровня будут применимы для использования на другом уровне; некоторые модули данных должны быть доступны более чем одному программному модулю; и в некоторых случаях будет важно, чтобы некоторые модули данных были недоступны для определенных программных модулей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Второй принцип – снизу вверх, при котором: 1) сначала создаются подпрограммы модулей нижнего уровня, 2) промежуточные шаги объединяют шаги нижнего уровня и 3) последний шаг связывает все предыдущие шаги вместе. Вся проблема не определена, пока не будет завершен последний шаг.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Последний принцип – принцип сквозного структурного контроля. </span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Структурирование программы – процесс определения и обеспечения соблюдения организации и дисциплины при проектировании и реализации всей программной системы. В то время как структурированное программирование применяется к стилю программирования, структурирование программы применяется к процессу определения модулей и их интерфейсов.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Сущность архитектуры любой системы заключается в разделении концепции системы в целом на составляющие ее компоненты, будь то автомобиль, дом, ноутбук или программная система. Хорошая архитектура также предписывает, как эти компоненты взаимодействуют во время выполнения. Акт идентификации составляющих компонентов системы называется декомпозицией системы.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Функциональная декомпозиция разбивает систему на ее строительные блоки в зависимости от функциональности системы.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Простой пример на рис. 1.3 показывает функциональную версию сценария ссуды клиенту.</span></p></div><div class="image section center zoomable" style="background: url(&quot;data/intr1/picture3.jpg?t=1614346141104&quot;) center center / 100% 100% no-repeat rgb(255, 255, 255); width: 400px; height: 192px;"><div class="zoom_icon"></div></div><div class="text section"><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Процесс состоит из нескольких шагов:</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">1. Добавление нового клиента.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">2. Обновление адреса клиента.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">3. Расчет кредита клиенту.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">4. Расчет процентов по кредиту.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">5. Расчет графика платежей по кредиту клиента.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">6. Изменение графика платежей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">«Методика структурной декомпозиции закрепила сложившийся алгоритмический подход к программированию, при котором основное внимание концентрируется на определении последовательности действий» [11].</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Поддержка принципов структурного программирования была заложена в основу так называемых процедурных языков программирования. Среди наиболее известных языков этой группы стоит назвать PL/1, ALGOL-68, Pascal, С.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">«Дальнейший рост сложности и размеров разрабатываемого ПО потребовал развития способов представления структурированных данных и, соответственно, в языках появляется возможность определения пользовательских типов данных. Одновременно усиливается стремление разграничить доступ к глобальным данным программы для уменьшения количества ошибок. Результатом было появление и развитие технологии модульного программирования» [11].</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Чтобы устранить проблему повторения идентичного кода на разных этапах проекта, была разработана модульность. Принцип модульности направлен на создание кодов в сегментах таким образом, чтобы реализовать определенную функцию, которая может быть назначена из любой части программы. Связанные функции помещены в один модуль. Поскольку модули независимы, программное обеспечение в целом становится набором функциональных единиц или также может быть подпрограммами, составляющими полную программу.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Модуль представляет собой отдельный программный компонент, который часто может использоваться в различных функциях вместе с другими компонентами системы. Идентичные функции собраны в блоке программного кода. Тем не менее отдельные функции разрабатываются как отдельные блоки кода, и в результате код может повторно использоваться другими приложениями.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Модульное программирование нацелено на разбиение и организацию кода с учетом выполняемой задачи. Таким образом, код становится многоразовым, его легче отлаживать и управлять им. Модульные коды предоставляют программистам простую возможность повторного использования кода. В случае если определенные задачи классифицируются по определенным функциям или классам, программисты могут повторно использовать этот конкретный код всякий раз, когда им нужно выполнить эту задачу снова.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Модульность в программировании позволяет программировать в команде. Руководители групп делят большую работу на большую команду программистов. Как правило, каждому программисту дается конкретная задача, которую он должен реализовать как часть полной программы. В конце концов вся работа, проделанная разными программистами, объединяется для создания всей программы. Это увеличивает скорость работы и обеспечивает специализацию.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">На рис. 1.4 показана архитектура программы, использующей модули.</span></p></div><div class="image section center zoomable" style="background: url(&quot;data/intr1/picture4.jpg?t=1614346141105&quot;) center center / 100% 100% no-repeat rgb(255, 255, 255); width: 337px; height: 200px;"><div class="zoom_icon"></div></div><div class="text section"><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Модульность в программировании также улучшает качество конкретной части кода. Когда общая программа разбита на более мелкие части и каждый разработчик берет на себя ответственность за определенный раздел, качество каждого отдельного раздела улучшается. В ситуации, когда программисту не нужно беспокоиться о программе в целом, он сосредотачивается на качестве своего отдельного фрагмента кода. В конце концов, когда все части объединены, меньше шансов встретить ошибки, которые, скорее всего, будут обнаружены в целом.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Модульный подход позволяет разрабатывать программы быстрее, поскольку небольшие подпрограммы легче понять, спроектировать и протестировать, чем большие программы. Определив входы и выходы модуля, программист может предоставить необходимые входные данные и проверить правильность модуля, изучив выходные данные. Затем отдельные модули связываются и помещаются компоновщиком в абсолютный исполняемый единый программный модуль. Наконец тестируется весь модуль.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">История развития объектно-ориентированного программирования (ООП) берет свое начало в конце 60-х годов. Первым объектно-ориентированным языком был язык программирования Simula, созданный в компьютерном центре в Норвегии. Язык предназначался для моделирования ситуаций реального мира. Особенностью Simula было то, что программа, написанная на языке, была организована по объектам программирования. Объекты имели инструкции, называемые методами, и данные, которые назывались переменными; методы и данные определяли поведение объекта. В процессе моделирования объект вел себя согласно своему стандартному поведению и, в случае необходимости, изменял данные для отражения влияния назначенного ему действия.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">К 1980-м объектно-ориентированное программирование стало заметным, а также было важно для разработки графических пользовательских интерфейсов. Использование объектно-ориентированного подхода привело к развитию языков моделирования, шаблонов проектирования и ряда других областей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Основополагающей идеей объектно-ориентированного подхода является объединение данных и действий, производимых над этими данными, в единое целое, которое называется объектом.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Объектно-ориентированное программирование – это модель компьютерного программирования, которая организует разработку программного обеспечения на основе данных или объектов, а не функций и логики. Объект можно определить как поле данных, которое имеет уникальные атрибуты и поведение.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">ООП фокусируется на объектах, которыми разработчики хотят манипулировать, а не на логике, необходимой для управления ими. Такой подход к программированию хорошо подходит для больших, сложных программ, которые активно обновляются или обслуживаются.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Возможность повторного использования уже имеющихся программных компонентов облегчает быструю разработку программного обеспечения и способствует производству дополнительных компонентов, которые сами могут быть повторно использованы в будущих разработках программного обеспечения. Лучше брать компоненты, созданные другими, чем создавать новые. Если существует хорошая библиотека повторно используемых компонентов, просмотр компонентов для определения возможностей повторного использования должен иметь приоритет перед написанием новых с нуля.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Быстрое развитие этой парадигмы в течение последних десяти лет имеет важные причины, среди которых: лучшее моделирование реальных приложений, а также возможность повторного использования программного обеспечения во время разработки программной системы. Идея повторного использования в объектно-ориентированном подходе привлекательна, потому что это не просто вопрос повторного использования кода подпрограммы, но также включает повторное использование любой общности, выраженной в иерархиях классов. Механизм наследования поощряет повторное использование в рамках объектно-ориентированного подхода, разрешая использование класса в измененной форме, когда от него происходит подкласс.</span></p></div><div class="text section"><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">Библиографический список</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">1. Ашарина, И.В. Объектно-ориентированное программирование в С++: лекции и упражнения : учеб. пособие / И.В. Ашарина. – Москва : Горячая линия – Телеком, 2012. – 319 с. – ISBN 978-5-9912-0423-1. – URL: https://e.lanbook.com/book/119830 (дата обращения: 10.06.2020). – Режим доступа: электрон.-библ. система «Лань», требуется авторизация.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">2. Васильев, А.Н. Самоучитель С++ с примерами и задачами/ А.Н. Васильев. – Санкт-Петербург : Наука и техника, 2016. – 480 c. – URL: https://e.lanbook.com/book/74667 (дата обращения: 10.06.2020). – Режим доступа: электрон.-библ. система «Лань», требуется авторизация.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">3. Васильев, А.Н. Объектно-ориентированное программирование на С++ / А.Н. Васильев. – Санкт-Петербург : Наука и техника, 2016. – 544 c. – ISBN 978-5-94387-984-5. – URL: https://e.lanbook.com/book/90227 (дата обращения: 10.06.2020). – Режим доступа: электрон.-библ. система «Лань», требуется авторизация.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">4. Васильев, В.Н. Основы программирования на языке C+ : учеб. пособие / В.Н. Васильев. – Саратов : ВИБ, 2013 ; Волгоград : Вузовское образование, 2013. – 72 с. – ISBN 978-5-9061-7234-1. – URL: http://www.iprbookshop.ru/11341.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">5. Васильев, А.Н. Программирование на С++ в примерах и задачах / А.Н. Васильев. – Москва : Издательство «Э», 2017. – 368 с. – ISBN 978-5-699-87445-3. –  Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">6. Влацкая, И.В. Проектирование и реализация прикладного программного обеспечения : учеб. пособие / И.В. Влацкая, Н.А. Заельская, Н.С. Надточий. – Оренбург : Оренбургский государственный университет, ЭБС АСВ, 2015. – 119 c. – ISBN 978-5-7410-1238-3. – URL: http://www.iprbookshop.ru/54145.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">7. Волкова, И.А. Основы объектно-ориентированного программирования. Язык программирования С++ : учеб. пособие для студентов 2 курса / И.А. Волкова, А.В. Иванов, Л.Е. Карпов. – Москва : Издательский отдел факультета ВМКМГУ, 2011. – 112 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">8. Гамма, Э. Приемы объектно-ориентированного проектирования. Паттерны проектирования / Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес. – Санкт-Петербург : Питер, 2015. – 368 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">9. Золотов, С.Ю. Проектирование информационных систем : учеб. пособие/ С.Ю. Золотов. – Томск : Томский государственный университет систем управления и радиоэлектроники ; Эль Контент, 2013. – 88 c. – ISBN 978-5-4332-0083-8. – URL: http://www.iprbookshop.ru/13965.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">10. Иванов, В.Б. Прикладное программирование на С/С++: с нуля до мультимедийных и сетевых приложений / В.Б. Иванов. – Москва : СОЛОН-ПРЕСС, 2008. – 240 с. – ISBN 978-5-91359-308-5. – URL: http://www.iprbookshop.ru/90397.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">11. Иванова, Г.С. Объектно-ориентированное программирование : учебник / Г.С. Иванова, Т.Н. Ничушкина ; под общ. ред. Г.С. Ивановой. – Москва : Изд-во МГТУ им. Н. Баумана, 2014. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">12. Казанский, А.А. Объектно-ориентированное программирование на языке MicrosoftVisual C# в среде разработки MicrosoftVisualStudio 2008 и .NET Framework : учеб. пособие и практикум. Ч. 3 / А.А. Казанский. – Москва : МГСУ, 2011. – 180 с. – ISBN 2227-8397. – URL: http://www.iprbookshop.ru/19258.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">13. Кивран, В.К. Программирование в среде Visual C++ 6 : учеб. пособие / В.К. Кивран. – Самара : СГАСУ : ЭБС АСВ, 2014. – 118 с. – ISBN 978-5-9585-0601-9. – URL: http://www.iprbookshop.ru/43185.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">14. Конова, Е.А. Алгоритмы и программы. Язык С++ : учеб. пособие / Е.А. Конова, Г.А. Поллак. – Изд. 2-е, стер. – Санкт-Петербург : Лань, 2017. – 384 с. – ISBN 978-5-8114-5431-0. – URL: https://e.lanbook.com/book/140730 (дата обращения: 23.10.2020). – Режим доступа: электрон.-библ. система «Лань», для авториз. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">15. Культин, Н.Б. С/С++ в задачах и примерах. – 2-е изд., перераб. и доп. – Санкт-Петербург : БХВ-Петербург, 2009. – 368 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">16. Лафоре, Р. Объектно-ориентированное программирование в С++/ Р. Лафоре. – Санкт-Петербург : Питер, 2004. – 902 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">17. Луцик, Ю.А. Объектно-ориентированное программирование на языке С++ : учеб. пособие / Ю.А. Луцик, В.Н. Комличенко. – Минск : БГУИР, 2008. – 266 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">18. Мейерс, С. Эффективный и современный С++: 42 рекомендации по использованию С++11 и С++14/ С. Мейерс ; пер. с англ. – Москва : ООО «И.Д.Вильямс», 2016. – 304 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">19. Николаев, Е.И. Объектно-ориентированное программирование. Ч. 1 : лабораторный практикум / Е.И. Николаев. – Ставрополь : Северо-Кавказский федеральный университет, 2015. – ISBN 2227-8397. – URL: http://www.iprbookshop.ru/62966.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">20. Николаев, Е.И. Объектно-ориентированное программирование. Ч. 2 : лабораторный практикум / Е.И. Николаев. – Ставрополь : Северо-Кавказский федеральный университет, 2015. – 156 c. — ISBN 2227-8397. – URL: http://www.iprbookshop.ru/63218.html (дата обращения: 23.10.2020). – – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">21. Новиков, П.В. Объектно-ориентированное программирование : учеб.-метод. пособие к лабораторным работам / П.В. Новиков. – Саратов : Вузовское образование, 2017. – 124 c. – ISBN 978-5-4487-0011-8. – URL: http://www.iprbookshop.ru/64650.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">22. Павловская, Т.А. C++. Объектно-ориентированное программирование : практикум / Т.А. Павловская, Ю.А. Щупак. – Санкт-Петербург : Питер, 2006. – 265 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">23. Павловская, Т.А. C/C++. Программирование на языке высокого уровня: для магистров и бакалавров : учебник для вузов / Т.А. Павловская. – Санкт-Петербург : Питер, 2013. – 460 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">24. Павловская, Т.А. C/C++. Процедурное и объектно-ориентированное программирование : учебник для студентов вузов / Т.А. Павловская. – Гриф МО. – Санкт-Петербург : Питер, 2015. – 495 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">25. Прата, С. Язык программирования С++. Лекции и упражнения : учебник / С. Прата ; пер. с англ. – Санкт-Петербург : ООО «ДиаСофтЮП», 2005. – 1104 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">26. Самуйлов, С.В. Объектно-ориентированное моделирование на основе UML : учеб. пособие / С.В. Самуйлов. – Саратов : Вузовское образование, 2016. – 37 c. – ISBN 2227-8397. – URL: http://www.iprbookshop.ru/47277.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">27. Сорокин, А.А. Объектно-ориентированное программирование. Курс лекций : учеб. пособие / А.А. Сорокин. – Ставрополь : Северо-Кавказский федеральный университет, 2014. – 174 c. – ISBN 2227-8397. – URL: http://www.iprbookshop.ru/63110.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">28. Липпман С. Язык программирования С++ : полное руководство / С. Липпман, Ж. Лажойе. – Москва, Санкт-Петербург : ДМК Пресс, Невский диалект, 2009. – 1104 c. – ISBN 978-5-4488-0136-5. – URL: http://www.iprbookshop.ru/89862.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">29. Тяпичев, Г.А. Быстрое программирование на С++ / Г.А. Тяпичев. – Москва : СОЛОН-Пресс, 2008. – 373 c. – ISBN 5-98003-162-6. – URL: http://www.iprbookshop.ru/90357.html (дата обращения: 23.10.2020). – Режим доступа: электрон.-библиотеч. система IPR BOOKS, для авторизир. пользователей.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">30. Шилдт, Г. Самоучитель C++ / Г. Шилдт ; пер. с англ. – 3-е изд. – Санкт-Петербург : БХВ-Петербург, 2005. – 688 с. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">31. Шилдт, Г. С++ : базовый курс / Г. Шилдт. – Москва : Издательский дом «Вильямс», 2016. – 624 c. – Текст : непосредственный.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">32. Malik, D.S. C++ programming: program design including data structures/ D.S. Malik. 7th ed. 2015. 1680 с.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">33. Malik, D.S. Data structures using C++/ D.S. Malik. 2nd ed. 2010. 912 с.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">34. Справочник по функциям C/C++. – URL: http://www.codenet.ru/progr/cpp/spr (дата обращения: 15.05.2020). – Загл. с экрана.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">35. C++ Reference. – URL: http://www.cppreference.com/wiki (дата обращения: 15.05.2020). – Загл. с экрана.</span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">36. BestProg. – URL: https://www.bestprog.net/ru/2018/08/16/example-of-unit-test-creating-in-microsoft-visual-studio-c_ru/ (дата обращения: 23.04.2020). – Загл. с экрана. </span></p><p style="text-indent:30px;text-align:justify;"><span style="color:#3f3f3f;font-family:font116087079304741927;font-size:14px;">37. Ravesli. Уроки программирования на языке С++. – URL: https://ravesli.com/uroki-cpp/ (дата обращения: 23.05.2020). – Загл. с экрана. </span></p></div></div></div></div></div><div class="vscrollbar" style="opacity: 0;"><div class="up"></div><div class="thumb" style="height: 28px; top: 71px;"></div><div class="down"></div></div></div></div></div>